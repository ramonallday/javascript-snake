<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title></title>
    <meta name="description" content="Description">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <style>
      * {
        margin: 0;
      }

      html, body {
        width: 100%;
        height: 100%;
      }

      body {
        background-color: #003b59;
        font-family: 'Open Sans', sans-serif;
        color: white;
        font-size: 16px;
      } 

      canvas {
          display: inline-block;
      }

      .vcenter {
        display: table;
        width: 100%; 
        height: 100%;
        text-align: center;
      }

      .vcell {
        display: table-cell;
        vertical-align: middle;
      }

      #controls {
        margin-top: 20px;
      }

      .controls {
        display: inline-block;
        background-color: white;
        color: #003b59;
        min-width: 20px;
        padding: 5px 10px;
        margin: 0 5px;
        cursor: pointer;
      }
    </style>
</head>

<body>

<div class="vcenter">
  <div class="vcell">
    <div id="content">
      <canvas id="game" width="400" height="400"></canvas>
    </div>
    <div id="score">0</div>
    <div id="controls"></div>
  </div>
</div>

</body>
<script>

var controlsElement = document.getElementById('controls');
var controls = [];
var scoreElement = document.getElementById('score');
var canvas = document.getElementById('game');
var context = canvas.getContext('2d');
var gameWidth = 400;
var gameHeight = 400;

var gameX = canvas.width / 2 - gameWidth / 2;
var gameY = canvas.height / 2 - gameHeight / 2;

var score = 0;

var size = 20;
var blocks = [];




var deltaX = size;
var deltaY = 0;

var gameOver = false;

//colors
var color = {
  snake: '#86ce00',
  background: '#006395',
  spawn: '#f9df05'
};

function Block(x, y, name) {
  this.name = name;
  this.x = x;
  this.y = y;
}

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

var Spawn = (function(){
  var x, y;

  var validXY = (function(){

    // store all combinations??
    var arr = [];

    for (var i = 0; i < gameWidth; i += size) {
      

      for (var y = 0; y < gameHeight; y += size) {


        arr.push( { x: i, y: y } );
      }
    }


    // var arr = [];
    // for (var i = 0; i < gameWidth; i += size) {
    //   arr.push( i );
    // }

    return arr;
  })();

 
  //iterate over blocks and check their x, y

  function getRandom(max) {
    return Math.floor(Math.random() * max);
  }
  

  function update() {

    var occupiedValues = [];

    blocks.forEach(function(b) {
      occupiedValues.push( b.x + ' ' + b.y );
    });

    var newArr = validXY.filter(function(pos) {
  
      return occupiedValues.indexOf( pos.x + ' ' + pos.y ) === -1;

    });

    x = newArr[ getRandom( newArr.length ) ].x;
    y = newArr[ getRandom( newArr.length ) ].y;


  }

  function getPos() {
    return { x: x, y: y };
  }

  //update position
  update();

  return {
    update: update,
    position: getPos
  };
})();

function overlap(x1, y1, w1, h1, x2, y2, w2, h2) {
  return !(((x1 + w1 - 1) < x2) ||
          ((x2 + w2 - 1) < x1) ||
          ((y1 + h1 - 1) < y2) ||
          ((y2 + h2 - 1) < y1));
}

function ateSpawn() {
  var lastElement = blocks[blocks.length - 1];

  if ( overlap(lastElement.x, lastElement.y, size, size, Spawn.position().x, Spawn.position().y, size, size) ) {
      
    // console.log(motion.currentX, motion.currentY);

    // console.log(Spawn.position().x, Spawn.position().y);

    blocks.push( new Block( motion.currentX, motion.currentY ) );

    Spawn.update();

    score += levels.reward[frameRate];
    scoreElement.innerHTML = score; 
  }

}

function detectCollision() {
  var lastElement = blocks[blocks.length - 1];

  //take last element and check by remaining
  blocks.slice(0, -1).forEach(function(b) {

    if ( overlap(lastElement.x, lastElement.y, size, size, b.x, b.y, size, size) ) {
      gameOver = true;
    }

    // if (lastElement.x === b.x && lastElement.y === b.y) {
    //   gameOver = true;
    // }
  });

  return gameOver;
}


function drawBlocks() {

  context.clearRect(0, 0, canvas.width, canvas.height);

  context.save();
  context.translate(gameX, gameY);

  context.save();
  context.fillStyle = color.background;
  context.fillRect(0 , 0, gameWidth, gameHeight);
  context.restore();



  

  //draw spawner 
  context.fillStyle = color.spawn;
  context.fillRect( Spawn.position().x, Spawn.position().y, size, size );


  blocks.forEach(function(b, index) {
      context.beginPath();
      context.rect(b.x, b.y, size, size);

      // context.fillStyle = (index === blocks.length - 1)  ? color.snake : 'yellow';

      context.fillStyle = color.snake;

      
      context.fill();
      // context.lineWidth = 2;
      // context.strokeStyle = 'red';
      // context.stroke();
    });

  context.restore();
}

blocks.push( new Block(0, 0) );
blocks.push( new Block(size, 0) );
blocks.push( new Block(size * 2, 0) );
blocks.push( new Block(size * 3, 0) );


var motion = {
  x: size * (blocks.length - 1),
  y: 0,
  direction: 'right',

  get currentDirection() {
    return this.direction;
  },

  set currentDirection(d) {
    this.direction = d;
  },

  get currentX() {
    return this.x;
  },

  set currentX(x) {
    this.x = x;
  },

  get currentY() {
    return this.y;
  },

  set currentY(y) {
    this.y = y;
  }
};

var levels = (function(){
  var reward = [];

  for (var i = 1, index = 5; i <= 12; i++, index++) {
    reward[index] = i;

    var el = document.createElement('span');
    el.className = 'controls';
    el.setAttribute('data-id', index);
    el.innerHTML = i;

    controlsElement.appendChild(el);

    controls.pop(el);

    el.addEventListener('click', function() {
      frameRate = this.getAttribute('data-id');
      frameLength = Math.round( 1000 / frameRate );
    });
  }
  

  return {
    reward: reward
  };

})(); 

//update last element to new postion


var frameRate = 10;
var frameLength = Math.round( 1000 / frameRate ); // this is ~1/30th of a second, in milliseconds (1000/30)
var lastFrame = 0;
var isRendering = false;

var render = function() {
  if(Date.now() - lastFrame > frameLength) {
    lastFrame = Date.now();

    // run your 30fps code here...

    //detect collision
    if (gameOver) {
      alert('game over');
      return;
    }

    

     
    


    motion.currentX += deltaX;
    motion.currentY += deltaY;


    if (motion.currentX + size > gameWidth) motion.currentX = 0;
    if (motion.currentX < 0) motion.currentX = gameWidth - size;




    if (motion.currentY + size > gameHeight) motion.currentY = 0;
    if (motion.currentY < 0) motion.currentY = gameHeight - size;


    blocks[0].x = motion.currentX;
    blocks[0].y = motion.currentY;

    var shifted = blocks.shift();

    blocks.push(shifted);

   
    drawBlocks();
    

    detectCollision();

    ateSpawn();

    isRendering = false;

  }
  
  requestAnimationFrame(render);
};

requestAnimationFrame(render);

window.addEventListener('keydown', function(e) {
  if (isRendering) {
    console.log('stop dat bullshit');
    return;
  }

  isRendering = true;

  if (e.keyCode === 38) {
    //go up
    if (motion.currentDirection === 'up' || motion.currentDirection === 'down') return;

    motion.currentDirection = 'up';

    deltaX = 0;
    deltaY = -size;
  }
  
  if (e.keyCode === 40) {
    //go down
    if (motion.currentDirection === 'up' || motion.currentDirection === 'down') return;

    motion.currentDirection = 'down';
    deltaX = 0;
    deltaY = size;

  }

  if (e.keyCode === 37) {
    //go left
    if (motion.currentDirection === 'left' || motion.currentDirection === 'right') return;

    motion.currentDirection = 'left';

    deltaX = -size;
    deltaY = 0;
  }

  if (e.keyCode === 39) {
    //go right
    if (motion.currentDirection === 'left' || motion.currentDirection === 'right') return;

    motion.currentDirection = 'right';

    deltaX = size;
    deltaY = 0;
  }


});

// whats the problem?

//problem is that deltaX and deltaY are changed even though view is not rendered

// what we can do?


</script>
</html>
